# -*- coding: utf-8 -*-
"""Week4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ciK0PWyVgZqJLczMbrvls9NXjaeo0fVP
"""

import re
import numpy as np
import pandas as pd
import xml.etree.ElementTree as ET

# 輸入 XML 檔路徑
xml_file = "./O-A0038-003.xml"

# 解析 XML
tree = ET.parse(xml_file)
root = tree.getroot()

ns = {"cwa": "urn:cwa:gov:tw:cwacommon:0.1"}

content = root.find(".//cwa:Content", ns).text
lon_start = float(root.find(".//cwa:BottomLeftLongitude", ns).text)
lat_start = float(root.find(".//cwa:BottomLeftLatitude", ns).text)
lon_end   = float(root.find(".//cwa:TopRightLongitude", ns).text)
lat_end   = float(root.find(".//cwa:TopRightLatitude", ns).text)

# 格點解析度
lon_step, lat_step = 0.03, 0.03
nx = int(round((lon_end - lon_start) / lon_step)) + 1
ny = int(round((lat_end - lat_start) / lat_step)) + 1
print(f"Grid size = {ny} x {nx}")

# 前處理 content
clean_str = re.sub(r"\s+", " ", content.strip())
values = re.findall(r"[-+]?\d+\.?\d*E[+-]?\d+", clean_str)
values = [float(v) for v in values]

if len(values) != nx * ny:
    print(f"⚠️ 警告：讀到 {len(values)} 筆，與期望 {nx*ny} 筆不符！")

# reshape 成網格
grid = np.array(values).reshape(ny, nx)

# 經緯度網格（用 linspace 避免浮點誤差）
lons = np.linspace(lon_start, lon_end, nx)
lats = np.linspace(lat_start, lat_end, ny)
lon_grid, lat_grid = np.meshgrid(lons, lats)

# 分類資料集
labels = (grid != -999.0).astype(int)
cls_data = pd.DataFrame({
    "lon": lon_grid.ravel(),
    "lat": lat_grid.ravel(),
    "label": labels.ravel()
})

# 回歸資料集
mask = grid != -999.0
reg_data = pd.DataFrame({
    "lon": lon_grid[mask],
    "lat": lat_grid[mask],
    "value": grid[mask]
})

# 四捨五入 (解決 120.57000000000001 問題)
for df in (cls_data, reg_data):
    df["lon"] = df["lon"].round(2)
    df["lat"] = df["lat"].round(2)

# 輸出 CSV
cls_data.to_csv("./classification_dataset.csv", index=False)
reg_data.to_csv("./regression_dataset.csv", index=False)

print("✅ 已輸出 classification_dataset.csv 與 regression_dataset.csv")

import torch
import torch.nn as nn
import torch.optim as optim
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import numpy as np
from sklearn.preprocessing import StandardScaler

# 分類模型 (cls_data)
X_cls = cls_data[["lon", "lat"]].values
y_cls = cls_data["label"].values

scaler_cls = StandardScaler()
X_cls = scaler_cls.fit_transform(X_cls)

X_cls = torch.tensor(X_cls, dtype=torch.float32)
y_cls = torch.tensor(y_cls, dtype=torch.long)

X_train, X_val, y_train, y_val = train_test_split(X_cls, y_cls, test_size=0.2, random_state=42)

class Classifier(nn.Module):
    def __init__(self):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(2, 64),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(64, 32),
            nn.ReLU(),
            nn.Linear(32, 2)
        )
    def forward(self, x):
        return self.net(x)

model_cls = Classifier()
optimizer_cls = optim.Adam(model_cls.parameters(), lr=1e-3, weight_decay=1e-4)
criterion_cls = nn.CrossEntropyLoss()

train_losses, val_losses, val_accs = [], [], []
epochs = 100
for epoch in range(epochs):
    model_cls.train()
    optimizer_cls.zero_grad()
    pred = model_cls(X_train)
    loss = criterion_cls(pred, y_train)
    loss.backward()
    optimizer_cls.step()

    model_cls.eval()
    with torch.no_grad():
        val_pred = model_cls(X_val)
        val_loss = criterion_cls(val_pred, y_val)
        acc = (val_pred.argmax(dim=1) == y_val).float().mean().item()

    train_losses.append(loss.item())
    val_losses.append(val_loss.item())
    val_accs.append(acc)

    if epoch % 10 == 0:
        print(f"[Classification Epoch {epoch}] "
              f"Train Loss: {loss.item():.4f}, Val Loss: {val_loss.item():.4f}, Val Acc: {acc:.4f}")

# 繪圖 (分類 Loss & Accuracy)
plt.figure(figsize=(12,4))

plt.subplot(1,2,1)
plt.plot(train_losses, label="Train Loss")
plt.plot(val_losses, label="Val Loss")
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.legend()
plt.title("Classification Loss Curve")

plt.subplot(1,2,2)
plt.plot(val_accs, label="Val Accuracy")
plt.xlabel("Epoch")
plt.ylabel("Accuracy")
plt.legend()
plt.title("Classification Accuracy Curve")

plt.tight_layout()
plt.show()

# Decision Boundary 可視化
xx, yy = np.meshgrid(
    np.linspace(X_cls[:,0].min(), X_cls[:,0].max(), 200),
    np.linspace(X_cls[:,1].min(), X_cls[:,1].max(), 200)
)
grid_points = torch.tensor(np.c_[xx.ravel(), yy.ravel()], dtype=torch.float32)
with torch.no_grad():
    Z = model_cls(grid_points).argmax(dim=1).numpy().reshape(xx.shape)

plt.figure(figsize=(6,5))
plt.contourf(xx, yy, Z, alpha=0.4, cmap="coolwarm")
plt.scatter(X_cls[:,0], X_cls[:,1], c=y_cls, edgecolor="k", cmap="coolwarm", s=20)
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.title("Classification Decision Boundary")
plt.show()

# 回歸模型 (reg_data)
X_reg = reg_data[["lon", "lat"]].values
y_reg = reg_data["value"].values

scaler_reg = StandardScaler()
X_reg = scaler_reg.fit_transform(X_reg)

X_reg = torch.tensor(X_reg, dtype=torch.float32)
y_reg = torch.tensor(y_reg, dtype=torch.float32).view(-1, 1)

X_train, X_val, y_train, y_val = train_test_split(X_reg, y_reg, test_size=0.2, random_state=42)

class Regressor(nn.Module):
    def __init__(self):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(2, 64),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(64, 32),
            nn.ReLU(),
            nn.Linear(32, 1)
        )
    def forward(self, x):
        return self.net(x)

model_reg = Regressor()
optimizer_reg = optim.Adam(model_reg.parameters(), lr=1e-3)
criterion_reg = nn.MSELoss()

train_losses, val_losses = [], []
epochs = 1000
for epoch in range(epochs):
    model_reg.train()
    optimizer_reg.zero_grad()
    pred = model_reg(X_train)
    loss = criterion_reg(pred, y_train)
    loss.backward()
    optimizer_reg.step()

    model_reg.eval()
    with torch.no_grad():
        val_pred = model_reg(X_val)
        val_loss = criterion_reg(val_pred, y_val)

    train_losses.append(loss.item())
    val_losses.append(val_loss.item())

    if epoch % 10 == 0:
        print(f"[Regression Epoch {epoch}] "
              f"Train Loss: {loss.item():.4f}, Val Loss: {val_loss.item():.4f}")

# 繪圖 (回歸 Loss)
plt.figure(figsize=(6,4))
plt.plot(train_losses, label="Train Loss")
plt.plot(val_losses, label="Val Loss")
plt.xlabel("Epoch")
plt.ylabel("MSE Loss")
plt.legend()
plt.title("Regression Loss Curve")
plt.show()

# 預測 vs. 真值 散佈圖
model_reg.eval()
with torch.no_grad():
    y_pred = model_reg(X_val).numpy()

plt.figure(figsize=(5,5))
plt.scatter(y_val.numpy(), y_pred, alpha=0.6)
plt.plot([y_val.min(), y_val.max()], [y_val.min(), y_val.max()], "r--")
plt.xlabel("True Value")
plt.ylabel("Predicted Value")
plt.title("Regression Prediction vs True")
plt.show()